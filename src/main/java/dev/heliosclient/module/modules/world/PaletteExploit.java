package dev.heliosclient.module.modules.world;

import dev.heliosclient.event.SubscribeEvent;
import dev.heliosclient.event.events.player.DisconnectEvent;
import dev.heliosclient.event.events.render.Render3DEvent;
import dev.heliosclient.event.events.world.ChunkDataEvent;
import dev.heliosclient.module.Categories;
import dev.heliosclient.module.Module_;
import dev.heliosclient.module.settings.BooleanSetting;
import dev.heliosclient.module.settings.DoubleSetting;
import dev.heliosclient.module.settings.SettingGroup;
import dev.heliosclient.util.color.ColorUtils;
import dev.heliosclient.util.render.Renderer3D;
import dev.heliosclient.util.render.color.QuadColor;
import it.unimi.dsi.fastutil.ints.IntRBTreeSet;
import it.unimi.dsi.fastutil.ints.IntSortedSet;
import net.minecraft.block.BlockState;
import net.minecraft.block.Blocks;
import net.minecraft.registry.entry.RegistryEntry;
import net.minecraft.util.math.Box;
import net.minecraft.util.math.ChunkPos;
import net.minecraft.util.math.Direction;
import net.minecraft.world.biome.Biome;
import net.minecraft.world.biome.BiomeKeys;
import net.minecraft.world.chunk.BiMapPalette;
import net.minecraft.world.chunk.Chunk;
import net.minecraft.world.chunk.ChunkSection;
import net.minecraft.world.chunk.PalettedContainer;
import net.minecraft.world.dimension.DimensionTypes;

import java.awt.*;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

public class PaletteExploit extends Module_ {
    public final Set<ChunkPos> newChunks = Collections.synchronizedSet(new HashSet<>());
    public final Set<ChunkPos> oldChunks = Collections.synchronizedSet(new HashSet<>());

    SettingGroup sgGeneral = new SettingGroup("General");
    BooleanSetting remove = sgGeneral.add(new BooleanSetting.Builder()
            .name("Remove on disable")
            .description("Removes stored chunks on module disable.")
            .defaultValue(false)
            .value(false)
            .onSettingChange(this)
            .build()
    );
    BooleanSetting removeOnDisconnect = sgGeneral.add(new BooleanSetting.Builder()
            .name("Remove on Disconnect")
            .description("Removes stored chunks when you disconnect from a server.")
            .defaultValue(true)
            .value(true)
            .onSettingChange(this)
            .build()
    );
    BooleanSetting outline = sgGeneral.add(new BooleanSetting.Builder()
            .name("Outline")
            .description("Draw outline")
            .value(true)
            .defaultValue(true)
            .onSettingChange(this)
            .build()
    );
    DoubleSetting outlineWidth = sgGeneral.add(new DoubleSetting.Builder()
            .name("Outline Width")
            .description("Width of the line")
            .min(0.0)
            .max(5.0f)
            .value(1d)
            .defaultValue(1d)
            .roundingPlace(1)
            .onSettingChange(this)
            .shouldRender(() -> outline.value)
            .build()
    );
    BooleanSetting fill = sgGeneral.add(new BooleanSetting.Builder()
            .name("Fill")
            .description("Draw side fill")
            .value(true)
            .defaultValue(true)
            .onSettingChange(this)
            .build()
    );

    public PaletteExploit() {
        super("PaletteExploit", "Newer new chunks which also works in end dimension using the PaletteExploit. Red means Old Chunks and Green means New Chunks ", Categories.WORLD);
        addSettingGroup(sgGeneral);
        addQuickSettings(sgGeneral.getSettings());
    }


    private void clearChunkData() {
        newChunks.clear();
        oldChunks.clear();
    }

    @Override
    public void onDisable() {
        super.onDisable();
        if (remove.value) {
            clearChunkData();
        }
    }

    @SubscribeEvent
    public void onDisconnect(DisconnectEvent event) {
        if (removeOnDisconnect.value) {
            clearChunkData();
        }
    }

    @SubscribeEvent
    public void onRender3d(Render3DEvent event) {
        Renderer3D.renderThroughWalls();
        for (ChunkPos cp : newChunks) {
            if (mc.getCameraEntity().getBlockPos().isWithinDistance(cp.getStartPos(), 1024)) {
                Box box = new Box(
                        cp.getStartX(), mc.world.getBottomY() - 3, cp.getStartZ(),
                        cp.getStartX() + 16, mc.world.getBottomY() - 3, cp.getStartZ() + 16);

                renderChunk(box, ChunkType.NEW, Direction.DOWN, Direction.EAST, Direction.WEST, Direction.NORTH, Direction.SOUTH);
            }
        }
        for (ChunkPos cp : oldChunks) {
            if (mc.getCameraEntity().getBlockPos().isWithinDistance(cp.getStartPos(), 1024)) {
                Box box = new Box(
                        cp.getStartX(), mc.world.getBottomY() - 3, cp.getStartZ(),
                        cp.getStartX() + 16, mc.world.getBottomY() - 3, cp.getStartZ() + 16);

                renderChunk(box, ChunkType.OLD, Direction.DOWN, Direction.EAST, Direction.WEST, Direction.NORTH, Direction.SOUTH);
            }
        }

        Renderer3D.stopRenderingThroughWalls();
    }
    /**
     * This code was provided by <a href="https://github.com/RacoonDog">Crosby</a>.
     * <p>
     * Credits to <a href="https://github.com/RacoonDog">crosby</a>, <a href="https://github.com/etianl">etianl</a> and <a href="https://github.com/rfresh2">rfresh</a> for the whole Palette Exploit
     * </p>
     */
    private void handleChunk(Chunk chunk) {
        if (mc.world.getDimensionEntry().matchesKey(DimensionTypes.THE_END)) {
            // rfresh found this one :pray
            PalettedContainer.Data<RegistryEntry<Biome>> data =  chunk.getSectionArray()[0].getBiomeContainer().slice().data;
            if (data.palette().get(0).matchesKey(BiomeKeys.PLAINS)) {
                if (!oldChunks.contains(chunk.getPos())) newChunks.add(chunk.getPos());
            } else {
                if (!newChunks.contains(chunk.getPos())) oldChunks.add(chunk.getPos());
            }
        } else {
            for (ChunkSection section : chunk.getSectionArray()) {
                if (section.isEmpty()) continue;

                PalettedContainer.Data<BlockState> data = section.getBlockStateContainer().data;
                if (data.palette() instanceof BiMapPalette<BlockState>) continue; // unordered check is expensive and not strictly necessary

                if (!data.palette().get(0).isOf(Blocks.AIR)) break;

                // you cant have compact storage of a section with air if the first block is not air
                // storage.get(0) == 0 acts as a fast short-circuit for the expensive isCompact() check
                if (data.storage().get(0) == 0 && isCompact(data)) break;

                if (!oldChunks.contains(chunk.getPos())) newChunks.add(chunk.getPos());
                return;
            }

            if (!newChunks.contains(chunk.getPos())) oldChunks.add(chunk.getPos());
        }
    }

    private static boolean isCompact(PalettedContainer.Data<BlockState> data) {
        int[] unpackedStorage = new int[16 * 16 * 16];
        data.storage().writePaletteIndices(unpackedStorage);

        IntSortedSet knownIndices = new IntRBTreeSet();

        for (int index : unpackedStorage) {
            if (knownIndices.add(index) && knownIndices.lastInt() != index) {
                return false;
            }
        }

        return true;
    }

    private void renderChunk(Box box, ChunkType type, Direction... exclude) {
        QuadColor chunkColor = QuadColor.single(getChunkTypeColor(type));
        if (outline.value && fill.value) {
            Renderer3D.drawBoxBoth(box, chunkColor, chunkColor, (float) outlineWidth.value, exclude);
        } else if (outline.value) {
            Renderer3D.drawBoxOutline(box, chunkColor, (float) outlineWidth.value, exclude);
        } else if (fill.value) {
            Renderer3D.drawBoxFill(box, chunkColor, exclude);
        }
    }

    public int getChunkTypeColor(ChunkType type) {
        if (type == ChunkType.NEW) {
            return ColorUtils.changeAlphaGetInt(Color.GREEN.getRGB(), 120);
        }
        if (type == ChunkType.OLD) {
            return ColorUtils.changeAlphaGetInt(Color.RED.getRGB(), 120);
        }
        return -1;
    }

    @SubscribeEvent
    public void onChunkData(ChunkDataEvent event) {
        //Not happening for sure
        if (mc.player == null) return;

        handleChunk(event.getChunk());
    }

    public enum ChunkType {
        NEW,
        OLD,
    }
}
