package dev.heliosclient.module.modules.world;

import dev.heliosclient.event.SubscribeEvent;
import dev.heliosclient.event.events.player.PlayerLeaveEvent;
import dev.heliosclient.event.events.render.Render3DEvent;
import dev.heliosclient.event.events.world.ChunkDataEvent;
import dev.heliosclient.module.Categories;
import dev.heliosclient.module.Module_;
import dev.heliosclient.module.settings.BooleanSetting;
import dev.heliosclient.module.settings.DoubleSetting;
import dev.heliosclient.module.settings.SettingGroup;
import dev.heliosclient.util.ColorUtils;
import dev.heliosclient.util.render.Renderer3D;
import dev.heliosclient.util.render.color.QuadColor;
import io.netty.buffer.Unpooled;
import net.minecraft.block.BlockState;
import net.minecraft.network.PacketByteBuf;
import net.minecraft.util.math.Box;
import net.minecraft.util.math.ChunkPos;
import net.minecraft.util.math.Direction;
import net.minecraft.world.World;
import net.minecraft.world.chunk.ChunkSection;
import net.minecraft.world.chunk.PalettedContainer;

import java.awt.*;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

public class PaletteExploit extends Module_ {
    private final Set<ChunkPos> newChunks = Collections.synchronizedSet(new HashSet<>());
    private final Set<ChunkPos> oldChunks = Collections.synchronizedSet(new HashSet<>());
    private final Set<ChunkPos> beingUpdatedOldChunks = Collections.synchronizedSet(new HashSet<>());
    private final Set<ChunkPos> oldGenerationOldChunks = Collections.synchronizedSet(new HashSet<>());

    SettingGroup sgGeneral = new SettingGroup("General");
    public BooleanSetting remove = sgGeneral.add(new BooleanSetting.Builder()
            .name("Remove on disable")
            .description("Removes stored chunks on module disable.")
            .defaultValue(false)
            .value(false)
            .onSettingChange(this)
            .build()
    );
    BooleanSetting outline = sgGeneral.add(new BooleanSetting.Builder()
            .name("Outline")
            .description("Draw outline")
            .value(true)
            .defaultValue(true)
            .onSettingChange(this)
            .build()
    );
    DoubleSetting outlineWidth = sgGeneral.add(new DoubleSetting.Builder()
            .name("Outline Width")
            .description("Width of the line")
            .min(0.0)
            .max(5.0f)
            .value(1d)
            .defaultValue(1d)
            .roundingPlace(1)
            .onSettingChange(this)
            .shouldRender(() -> outline.value)
            .build()
    );
    BooleanSetting fill = sgGeneral.add(new BooleanSetting.Builder()
            .name("Fill")
            .description("Draw side fill")
            .value(true)
            .defaultValue(true)
            .onSettingChange(this)
            .build()
    );

    public PaletteExploit() {
        super("PaletteExploit", "Newer new chunks which also works in end dimension using the PaletteExploit by Trouser-Streak. Brown means old generation chunks, Red means Old Chunks, Yellow means Being updated, Green means New Chunks ", Categories.WORLD);
        addSettingGroup(sgGeneral);
        addQuickSettings(sgGeneral.getSettings());
    }


    private void clearChunkData() {
        newChunks.clear();
        oldChunks.clear();
        beingUpdatedOldChunks.clear();
        oldGenerationOldChunks.clear();
    }

    @Override
    public void onDisable() {
        super.onDisable();
        if (remove.value) {
            clearChunkData();
        }
    }

    @SubscribeEvent
    public void onDisconnect(PlayerLeaveEvent event) {
        if (remove.value) {
            clearChunkData();
        }
    }

    @SubscribeEvent
    public void onRender3d(Render3DEvent event) {
        Renderer3D.renderThroughWalls();
        for (ChunkPos cp : newChunks) {
            if (mc.getCameraEntity().getBlockPos().isWithinDistance(cp.getStartPos(), 1024)) {
                Box box = new Box(
                        cp.getStartX(), mc.world.getBottomY() - 3, cp.getStartZ(),
                        cp.getStartX() + 16, mc.world.getBottomY() - 3, cp.getStartZ() + 16);

                renderChunk(box, ChunkType.NEW, Direction.DOWN, Direction.EAST, Direction.WEST, Direction.NORTH, Direction.SOUTH);
            }
        }
        for (ChunkPos cp : oldChunks) {
            if (mc.getCameraEntity().getBlockPos().isWithinDistance(cp.getStartPos(), 1024)) {
                Box box = new Box(
                        cp.getStartX(), mc.world.getBottomY() - 3, cp.getStartZ(),
                        cp.getStartX() + 16, mc.world.getBottomY() - 3, cp.getStartZ() + 16);

                renderChunk(box, ChunkType.OLD, Direction.DOWN, Direction.EAST, Direction.WEST, Direction.NORTH, Direction.SOUTH);
            }
        }
        for (ChunkPos cp : beingUpdatedOldChunks) {
            if (mc.getCameraEntity().getBlockPos().isWithinDistance(cp.getStartPos(), 1024)) {
                Box box = new Box(
                        cp.getStartX(), mc.world.getBottomY() - 3, cp.getStartZ(),
                        cp.getStartX() + 16, mc.world.getBottomY() - 3, cp.getStartZ() + 16);

                renderChunk(box, ChunkType.BEING_UPDATED, Direction.DOWN, Direction.EAST, Direction.WEST, Direction.NORTH, Direction.SOUTH);
            }
        }
        for (ChunkPos cp : oldGenerationOldChunks) {
            if (mc.getCameraEntity().getBlockPos().isWithinDistance(cp.getStartPos(), 1024)) {
                Box box = new Box(
                        cp.getStartX(), mc.world.getBottomY() - 3, cp.getStartZ(),
                        cp.getStartX() + 16, mc.world.getBottomY() - 3, cp.getStartZ() + 16);

                renderChunk(box, ChunkType.NEW, Direction.DOWN, Direction.EAST, Direction.WEST, Direction.NORTH, Direction.SOUTH);
            }
        }

        Renderer3D.stopRenderingThroughWalls();
    }

    private void renderChunk(Box box, ChunkType type, Direction... exclude) {
        QuadColor chunkColor = QuadColor.single(getChunkTypeColor(type));
        if (outline.value && fill.value) {
            Renderer3D.drawBoxBoth(box, chunkColor, chunkColor, (float) outlineWidth.value, exclude);
        } else if (outline.value) {
            Renderer3D.drawBoxOutline(box, chunkColor, (float) outlineWidth.value, exclude);
        } else if (fill.value) {
            Renderer3D.drawBoxFill(box, chunkColor, exclude);
        }
    }

    private int getChunkTypeColor(ChunkType type) {
        if (type == ChunkType.NEW) {
            return ColorUtils.changeAlphaGetInt(Color.GREEN.getRGB(), 120);
        }
        if (type == ChunkType.OLD) {
            return ColorUtils.changeAlphaGetInt(Color.RED.getRGB(), 120);
        }
        if (type == ChunkType.BEING_UPDATED) {
            return ColorUtils.changeAlphaGetInt(Color.YELLOW.getRGB(), 120);
        }
        if (type == ChunkType.OLD_GEN) {
            return ColorUtils.rgbaToInt(70, 29, 3, 120);
        }
        return -1;
    }

    /**
     * This part of the code has been directly used from
     * <a href="https://github.com/etianl/Trouser-Streak/blob/main/src/main/java/pwn/noobs/trouserstreak/modules/NewerNewChunks.java#L742">Trouser-Streak</a> by etianl.
     * Honestly this is crazy fr. I think I will refactor this and make it look cleaner in the future.
     * Big respect man.
     */
    @SubscribeEvent
    public void onChunkData(ChunkDataEvent event) {
        //Not happening for sure
        if (mc.player == null) return;

        PacketByteBuf buf = null;
        buf = event.getPacket().getChunkData().getSectionsDataBuf();

        ChunkPos oldpos = new ChunkPos(event.getPacket().getChunkX(), event.getPacket().getChunkZ());

        boolean isNewChunk = false;
        boolean isOldGeneration = false;
        boolean chunkIsBeingUpdated = false;


        if (mc.world.getRegistryKey() == World.END) {
            PacketByteBuf bufferCopy = new PacketByteBuf(Unpooled.copiedBuffer(buf.nioBuffer())); //copy the packetByteBuf for later use
            if (bufferCopy.readableBytes() < 2) return;

            try {
                short blockCount = bufferCopy.readShort();
                if (bufferCopy.readableBytes() < 1) return;
                int blockBitsPerEntry2 = bufferCopy.readUnsignedByte();
                if (blockBitsPerEntry2 == 0) {
                    int singleBlockValue = bufferCopy.readVarInt();
                    bufferCopy.readVarInt(); // Data Array Length (should be 0)
                } else if (blockBitsPerEntry2 >= 4 && blockBitsPerEntry2 <= 8) {
                    int blockPaletteLength = bufferCopy.readVarInt();
                    for (int i = 0; i < blockPaletteLength; i++) {
                        int blockPaletteEntry = bufferCopy.readVarInt();
                    }
                    int blockDataArrayLength = bufferCopy.readVarInt();
                    if (bufferCopy.readableBytes() >= blockDataArrayLength * 8) {
                        bufferCopy.skipBytes(blockDataArrayLength * 8);
                    } else {
                        bufferCopy.skipBytes(bufferCopy.readableBytes());
                        return;
                    }
                } else if (blockBitsPerEntry2 == 15) {
                    int blockDataArrayLength = bufferCopy.readVarInt();
                    if (bufferCopy.readableBytes() >= blockDataArrayLength * 8) {
                        bufferCopy.skipBytes(blockDataArrayLength * 8);
                    } else {
                        bufferCopy.skipBytes(bufferCopy.readableBytes());
                        return;
                    }
                } else {
                    return;
                }

                if (bufferCopy.readableBytes() < 1) {
                    return;
                }

                int biomeBitsPerEntry = bufferCopy.readUnsignedByte();

                if (biomeBitsPerEntry == 0) {
                    int singleBiomeValue = bufferCopy.readVarInt();
                    if (singleBiomeValue == 55) {
                        isOldGeneration = true;
                    }
                    bufferCopy.readVarInt(); // Data Array Length (should be 0)
                } else if (biomeBitsPerEntry >= 1 && biomeBitsPerEntry <= 3) {
                    int biomePaletteLength = bufferCopy.readVarInt();
                    for (int i = 0; i < biomePaletteLength; i++) {
                        if (bufferCopy.readableBytes() < 1) {
                            break;
                        }
                        int biomePaletteEntry = bufferCopy.readVarInt();
                        if (biomePaletteEntry == 55) {
                            isOldGeneration = true;
                            break;
                        }
                    }
                } else {
                    //no need to read if other biomeBitsPerEntry values, we can just return here
                    return;
                }
            } catch (Exception ignored) {
            }
        }

        if (buf.readableBytes() < 3) return; // Ensure we have at least 3 bytes (short + byte)

        boolean firstchunkappearsnew = false;
        int loops = 0;
        int newChunkQuantifier = 0;
        int oldChunkQuantifier = 0;

        try {
            while (buf.readableBytes() > 0 && loops < 8) {
                // Chunk Section structure
                short blockCount = buf.readShort();

                // Block states Paletted Container
                if (buf.readableBytes() < 1) break;
                int blockBitsPerEntry2 = buf.readUnsignedByte();

                if (blockBitsPerEntry2 == 0) {
                    // Single valued palette
                    int singleBlockValue = buf.readVarInt();
                    buf.readVarInt(); // Data Array Length (should be 0)
                } else if (blockBitsPerEntry2 >= 4 && blockBitsPerEntry2 <= 8) {
                    ChunkSection section = event.getChunk().getSectionArray()[loops];
                    PalettedContainer<BlockState> palettedContainer = section.getBlockStateContainer();
                    Set<BlockState> bstates = new HashSet<>();
                    for (int x = 0; x < 16; x++) {
                        for (int y = 0; y < 16; y++) {
                            for (int z = 0; z < 16; z++) {
                                bstates.add(palettedContainer.get(x, y, z));
                            }
                        }
                    }
                    // Indirect palette
                    int blockPaletteLength = buf.readVarInt();
                    int isNewSection = 0;
                    int isBeingUpdatedSection = 0;
                    int bstatesSize = bstates.size();
                    if (bstatesSize <= 1) bstatesSize = blockPaletteLength;
                    if (bstatesSize < blockPaletteLength) {
                        isNewSection = 2;
                        newChunkQuantifier++; //double the weight of this
                    }
                    for (int i = 0; i < blockPaletteLength; i++) {
                        int blockPaletteEntry = buf.readVarInt();
                        if (i == 0 && loops == 0 && blockPaletteEntry == 0 && mc.world.getRegistryKey() != World.END)
                            firstchunkappearsnew = true;
                        if (i == 0 && blockPaletteEntry == 0 && mc.world.getRegistryKey() != World.NETHER && mc.world.getRegistryKey() != World.END)
                            isNewSection++;
                        if (i == 1 && (blockPaletteEntry == 80 || blockPaletteEntry == 1 || blockPaletteEntry == 9 || blockPaletteEntry == 5781) && mc.world.getRegistryKey() != World.NETHER && mc.world.getRegistryKey() != World.END)
                            isNewSection++;
                        if (i == 2 && (blockPaletteEntry == 5781 || blockPaletteEntry == 10 || blockPaletteEntry == 22318) && mc.world.getRegistryKey() != World.NETHER && mc.world.getRegistryKey() != World.END)
                            isNewSection++;
                        if (loops == 4 && blockPaletteEntry == 79 && mc.world.getRegistryKey() != World.NETHER && mc.world.getRegistryKey() != World.END) {
                            //System.out.println("CHUNK IS BEING UPDATED!!!!!!");
                            if (!chunkIsBeingUpdated) chunkIsBeingUpdated = true;
                        }
                        if (blockPaletteEntry == 0 && (mc.world.getRegistryKey() == World.NETHER || mc.world.getRegistryKey() == World.END))
                            isBeingUpdatedSection++;
                    }
                    if (isBeingUpdatedSection >= 2) oldChunkQuantifier++;
                    if (isNewSection >= 2) newChunkQuantifier++;

                    // Data Array
                    int blockDataArrayLength = buf.readVarInt();
                    if (buf.readableBytes() >= blockDataArrayLength * 8) {
                        buf.skipBytes(blockDataArrayLength * 8);
                    } else {
                        buf.skipBytes(buf.readableBytes());
                        break;
                    }
                } else if (blockBitsPerEntry2 == 15) {
                    // Direct palette (no palette sent)
                    int blockDataArrayLength = buf.readVarInt();
                    if (buf.readableBytes() >= blockDataArrayLength * 8) {
                        buf.skipBytes(blockDataArrayLength * 8);
                    } else {
                        buf.skipBytes(buf.readableBytes());
                        break;
                    }
                } else {
                    break;
                }

                // Biomes Palette Container
                if (buf.readableBytes() < 1) {
                    break;
                }

                int biomeBitsPerEntry = buf.readUnsignedByte();

                if (biomeBitsPerEntry == 0) {
                    // Single valued palette
                    int singleBiomeValue = buf.readVarInt();
                    if (singleBiomeValue == 39 && mc.world.getRegistryKey() == World.END) isNewChunk = true;
                    buf.readVarInt(); // Data Array Length (should be 0)
                } else if (biomeBitsPerEntry >= 1 && biomeBitsPerEntry <= 3) {
                    // Indirect palette
                    int biomePaletteLength = buf.readVarInt();
                    for (int i = 0; i < biomePaletteLength; i++) {
                        if (buf.readableBytes() < 1) {
                            break;
                        }
                        int biomePaletteEntry = buf.readVarInt();
                        if (i == 0 && biomePaletteEntry == 39 && mc.world.getRegistryKey() == World.END)
                            isNewChunk = true;
                        if (!isNewChunk && i == 0 && biomePaletteEntry != 55 && mc.world.getRegistryKey() == World.END)
                            isNewChunk = false;
                    }

                    // Data Array
                    if (buf.readableBytes() >= 1) {
                        int biomeDataArrayLength = buf.readVarInt();
                        if (buf.readableBytes() >= biomeDataArrayLength * 8) {
                            buf.skipBytes(biomeDataArrayLength * 8);
                        } else {
                            buf.skipBytes(buf.readableBytes());
                            break;
                        }
                    } else {
                        break;
                    }
                } else if (biomeBitsPerEntry == 6) {
                    // Direct palette (no palette sent)
                    int biomeDataArrayLength = buf.readVarInt();
                    if (buf.readableBytes() >= biomeDataArrayLength * 8) {
                        buf.skipBytes(biomeDataArrayLength * 8);
                    } else {
                        buf.skipBytes(buf.readableBytes());
                        break;
                    }
                } else {
                    break;
                }

                loops++;
            }

            if (loops > 0) {
                if ((mc.world.getRegistryKey() == World.NETHER || mc.world.getRegistryKey() == World.END)) {
                    double oldpercentage = ((double) oldChunkQuantifier / loops) * 100;
                    //System.out.println("Percentage: " + oldpercentage);
                    if (oldpercentage >= 25) chunkIsBeingUpdated = true;
                } else if (mc.world.getRegistryKey() != World.NETHER && mc.world.getRegistryKey() != World.END) {
                    double percentage = ((double) newChunkQuantifier / loops) * 100;
                    //System.out.println("Percentage: " + percentage);
                    if (percentage >= 65) isNewChunk = true;
                }
            }
        } catch (Exception e) {
            if ((mc.world.getRegistryKey() == World.NETHER || mc.world.getRegistryKey() == World.END)) {
                double oldpercentage = ((double) oldChunkQuantifier / loops) * 100;
                if (oldpercentage >= 25) chunkIsBeingUpdated = true;
            } else if (mc.world.getRegistryKey() != World.NETHER && mc.world.getRegistryKey() != World.END) {
                double percentage = ((double) newChunkQuantifier / loops) * 100;
                if (percentage >= 65) isNewChunk = true;
            }
        }

        if (firstchunkappearsnew) isNewChunk = true;
        boolean bewlian = (mc.world.getRegistryKey() == World.END) ? isNewChunk : !isOldGeneration;
        if (isNewChunk && !chunkIsBeingUpdated && bewlian) {
            if (!oldGenerationOldChunks.contains(oldpos) && !beingUpdatedOldChunks.contains(oldpos) && !oldChunks.contains(oldpos)) {
                newChunks.add(oldpos);
            }
        } else if (!isNewChunk && !chunkIsBeingUpdated && isOldGeneration) {
            if (!oldGenerationOldChunks.contains(oldpos) && !beingUpdatedOldChunks.contains(oldpos) && !oldChunks.contains(oldpos) && !newChunks.contains(oldpos)) {
                oldGenerationOldChunks.add(oldpos);
            }
        } else if (chunkIsBeingUpdated) {
            if (!oldGenerationOldChunks.contains(oldpos) && !beingUpdatedOldChunks.contains(oldpos) && !oldChunks.contains(oldpos) && !newChunks.contains(oldpos)) {
                beingUpdatedOldChunks.add(oldpos);
            }
        } else if (!isNewChunk) {
            if (!oldGenerationOldChunks.contains(oldpos) && !beingUpdatedOldChunks.contains(oldpos) && !oldChunks.contains(oldpos) && !newChunks.contains(oldpos)) {
                oldChunks.add(oldpos);
            }
        }

    }

    private enum ChunkType {
        NEW,
        OLD,
        BEING_UPDATED,
        OLD_GEN
    }
}
